name: Automated Service CI

# DISABLED - Kept for reference only
# on:
#   push:
#     branches: [master, feature/automated-service-deployment]
#     paths:
#       - 'cmd/**/go.mod'

# This pipeline is disabled in favor of the new two-pipeline approach:
# - pr-validation.yml for PR validation with draft releases
# - production-deployment.yml for master branch deployments
on:
  workflow_dispatch:  # Manual trigger only

env:
  REGISTRY: us.icr.io/dia-registry
  
jobs:
  detect-service-changes:
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.detect.outputs.services }}
      has-changes: ${{ steps.detect.outputs.has-changes }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect go.mod changes in services
        id: detect
        run: |
          # Get changed go.mod files in cmd directory
          changed_files=$(git diff --name-only HEAD~1 HEAD | grep '^cmd/.*/go\.mod$' || true)
          
          if [ -z "$changed_files" ]; then
            echo "has-changes=false" >> $GITHUB_OUTPUT
            echo "services=[]" >> $GITHUB_OUTPUT
            echo "No service go.mod files changed"
            exit 0
          fi
          
          echo "has-changes=true" >> $GITHUB_OUTPUT
          echo "Changed go.mod files:"
          echo "$changed_files"
          
          # Build services array
          services="["
          first=true
          
          for file in $changed_files; do
            service_dir=$(dirname "$file")
            service_name=$(basename "$service_dir")
            
            # Extract version from go.mod module line
            version=$(grep -E "^module.*" "$file" | grep -o 'v[0-9]\+\.[0-9]\+\.[0-9]\+[^[:space:]]*' || echo "")
            
            # If no version in module line, try to extract from require section
            if [ -z "$version" ]; then
              version=$(grep "github.com/diadata-org/diadata" "$file" | grep -o 'v[0-9]\+\.[0-9]\+\.[0-9]\+[^[:space:]]*' | head -1 || echo "")
            fi
            
            if [ -z "$version" ]; then
              echo "Warning: Could not extract version from $file"
              continue
            fi
            
            if [ "$first" = true ]; then
              first=false
            else
              services="$services,"
            fi
            
            services="$services{\"name\":\"$service_name\",\"path\":\"$service_dir\",\"version\":\"$version\"}"
          done
          
          services="$services]"
          
          echo "services=$services" >> $GITHUB_OUTPUT
          echo "Detected services: $services"

  create-release:
    name: "Create release ${{ matrix.service.name }}"
    needs: detect-service-changes
    if: needs.detect-service-changes.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-service-changes.outputs.services) }}
      fail-fast: false
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4


      - name: Extract and validate version
        id: version
        run: |
          service_name="${{ matrix.service.name }}"
          service_path="${{ matrix.service.path }}"
          version="${{ matrix.service.version }}"
          
          echo "Processing service: $service_name"
          echo "Service path: $service_path"
          echo "Extracted version: $version"
          
          # Validate version format
          if [[ ! "$version" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Error: Invalid version format '$version'. Expected format: v1.2.3"
            exit 1
          fi
          
          echo "version=$version" >> $GITHUB_OUTPUT
          echo "service-name=$service_name" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: "${{ steps.version.outputs.version }}"
          name: "${{ steps.version.outputs.version }}"
          body: |
            ## Service Release: ${{ steps.version.outputs.service-name }}
            
            **Version:** ${{ steps.version.outputs.version }}
            **Service Path:** ${{ matrix.service.path }}
            
            ### Changes
            This release contains updates to the ${{ steps.version.outputs.service-name }} service.
            
            ---
            *This release was automatically created by the CI/CD pipeline.*
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  lint-service:
    name: "Lint ${{ matrix.service.name }}"
    needs: [detect-service-changes, create-release]
    if: needs.detect-service-changes.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-service-changes.outputs.services) }}
      fail-fast: false
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.22'
      # ensure all dependencies are downloaded and the go.sum file is properly populated.
      - name: Download and tidy Go modules
        run: |
          cd ${{ matrix.service.path }}
          go mod tidy
          go mod download

      - name: golangci-lint
        uses: golangci/golangci-lint-action@v6
        with:
          version: v1.61
          working-directory: ${{ matrix.service.path }}
          args: --config=../../../.golangci.yml --out-format=colored-line-number
          only-new-issues: true

  test-service:
    name: "Test ${{ matrix.service.name }}"
    needs: [detect-service-changes, create-release, lint-service]
    if: needs.detect-service-changes.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-service-changes.outputs.services) }}
      fail-fast: false
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.22'

      - name: Wait for Go proxy indexing
        run: |
          echo "Waiting 30 seconds for Go module proxy to index ${{ matrix.service.version }}..."
          sleep 30

      - name: Test service
        run: |
          service_path="${{ matrix.service.path }}"
          echo "Testing service in: $service_path"
          
          cd "$service_path"
          
          # Try go mod tidy with retry logic (up to 4 minutes total)
          echo "Running go mod tidy with retry..."
          for i in {1..8}; do
            echo "Attempt $i: Running go mod tidy..."
            if go mod tidy; then
              echo "‚úÖ Success!"
              break
            else
              if [ $i -lt 8 ]; then
                echo "‚ùå Failed, waiting 30 seconds..."
                sleep 30
              else
                echo "‚ùå All attempts failed after 4 minutes"
                exit 1
              fi
            fi
          done
          
          # Run tests if any exist
          if find . -name "*_test.go" | head -1 | grep -q .; then
            echo "Running tests..."
            go test -v ./...
          else
            echo "No tests found, checking if code builds..."
            go build -v .
          fi

  build-and-release:
    name: "Build ${{ matrix.service.name }}"
    needs: [detect-service-changes, create-release, lint-service, test-service]
    if: needs.detect-service-changes.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-service-changes.outputs.services) }}
      fail-fast: false
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Extract and validate version
        id: version
        run: |
          service_name="${{ matrix.service.name }}"
          service_path="${{ matrix.service.path }}"
          version="${{ matrix.service.version }}"
          
          echo "Processing service: $service_name"
          echo "Service path: $service_path"
          echo "Extracted version: $version"
          
          # Validate version format
          if [[ ! "$version" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Error: Invalid version format '$version'. Expected format: v1.2.3"
            exit 1
          fi
          
          echo "version=$version" >> $GITHUB_OUTPUT
          echo "service-name=$service_name" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3


      - name: Log in to IBM Cloud Container Registry
        run: |
          echo "${{ secrets.IBM_CLOUD_API_KEY }}" | docker login us.icr.io -u iamapikey --password-stdin

      - name: Find Dockerfile for service
        id: dockerfile
        run: |
          service_name="${{ steps.version.outputs.service-name }}"
          service_path="${{ matrix.service.path }}"
          
          # Look for Dockerfile in multiple locations
          dockerfile=""
          
          # Check service directory first
          if [ -f "$service_path/Dockerfile" ]; then
            dockerfile="$service_path/Dockerfile"
          # Check for Dockerfile-{service} pattern in root
          elif [ -f "Dockerfile-$service_name" ]; then
            dockerfile="Dockerfile-$service_name"
          # Check for dockerfile in service directory with service name
          elif [ -f "$service_path/Dockerfile-$service_name" ]; then
            dockerfile="$service_path/Dockerfile-$service_name"
          # Check build directory for Dockerfile-{service} pattern
          elif [ -f "build/Dockerfile-$service_name" ]; then
            dockerfile="build/Dockerfile-$service_name"
          else
            echo "Error: Could not find Dockerfile for service $service_name"
            echo "Searched locations:"
            echo "  - $service_path/Dockerfile"
            echo "  - Dockerfile-$service_name"
            echo "  - $service_path/Dockerfile-$service_name"
            echo "  - build/Dockerfile-$service_name"
            exit 1
          fi
          
          echo "dockerfile=$dockerfile" >> $GITHUB_OUTPUT
          echo "Found Dockerfile: $dockerfile"

      - name: Build and push Docker image
        run: |
          service_name="${{ steps.version.outputs.service-name }}"
          version="${{ steps.version.outputs.version }}"
          dockerfile="${{ steps.dockerfile.outputs.dockerfile }}"
          
          # Convert service name to lowercase for Docker registry
          service_name_lower=$(echo "$service_name" | tr '[:upper:]' '[:lower:]')
          
          version_tag="$REGISTRY/$service_name_lower:$version"
          latest_tag="$REGISTRY/$service_name_lower:latest"
          
          echo "Building Docker image:"
          echo "  Service: $service_name"
          echo "  Version: $version"
          echo "  Dockerfile: $dockerfile"
          echo "  Tags: $version_tag, $latest_tag"
          
          # Build the image
          docker build \
            -f "$dockerfile" \
            -t "$version_tag" \
            -t "$latest_tag" \
            --build-arg SERVICE_NAME="$service_name_lower" \
            --build-arg VERSION="$version" \
            .
          
          # Push both tags
          echo "Pushing Docker images..."
          docker push "$version_tag"
          docker push "$latest_tag"
          
          echo "‚úÖ Successfully built and pushed:"
          echo "  - $version_tag"
          echo "  - $latest_tag"
          

  summary:
    needs: [detect-service-changes, create-release, lint-service, test-service, build-and-release]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Pipeline Summary
        run: |
          if [ "${{ needs.detect-service-changes.outputs.has-changes }}" = "true" ]; then
            services='${{ needs.detect-service-changes.outputs.services }}'
            count=$(echo "$services" | jq length)
            
            echo "## üöÄ CI Pipeline Summary"
            echo ""
            echo "**Services processed:** $count"
            echo ""
            echo "### Services built and released:"
            echo "$services" | jq -r '.[] | "- **\(.name)** version \(.version)"'
            echo ""
            echo "## üìä Job Results:"
            echo "- **Release:** ${{ needs.create-release.result }}"
            echo "- **Lint:** ${{ needs.lint-service.result }}"
            echo "- **Test:** ${{ needs.test-service.result }}"
            echo "- **Build:** ${{ needs.build-and-release.result }}"
            
            echo ""
            echo "## üîç Audit Report"
            echo "**Triggered by:** ${{ github.actor }}"
            echo "**Branch:** ${{ github.ref }}"
            echo "**Commit:** ${{ github.sha }}"
            echo "**Repository:** ${{ github.repository }}"
            echo "**Timestamp:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
            echo "**Workflow:** ${{ github.workflow }}"
            echo "**Run ID:** ${{ github.run_id }}"
            
            if [ "${{ needs.lint-service.result }}" = "success" ] && [ "${{ needs.test-service.result }}" = "success" ] && [ "${{ needs.build-and-release.result }}" = "success" ]; then
              echo ""
              echo "üéâ **All services processed successfully!**"
              echo ""
              echo "### Services Deployed:"
              echo "$services" | jq -r '.[] | "- **\(.name)** ‚Üí us.icr.io/dia-registry/\(.name | ascii_downcase):\(.version)"'
            else
              echo ""
              echo "‚ö†Ô∏è **Pipeline failed. Services were NOT deployed.**"
              echo ""
              echo "**Failed stages:**"
              [ "${{ needs.lint-service.result }}" != "success" ] && echo "- üî¥ Linting failed"
              [ "${{ needs.test-service.result }}" != "success" ] && echo "- üî¥ Testing failed" 
              [ "${{ needs.build-and-release.result }}" != "success" ] && echo "- üî¥ Build/Deploy failed"
            fi
          else
            echo "## ‚ÑπÔ∏è No Service Changes Detected"
            echo ""
            echo "No service go.mod files were modified in this push."
            echo "CI pipeline was skipped."
          fi